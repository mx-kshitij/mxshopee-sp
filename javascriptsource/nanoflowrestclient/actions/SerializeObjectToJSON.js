// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import { Big } from "big.js";

// BEGIN EXTRA CODE
// END EXTRA CODE

/**
 * Creates a JSON string from Mendix objects. It will use an implicit mapping that will follow all associations that have been set. 
 * @param {MxObject} inputObj
 * @returns {Promise.<string>}
 */
export async function SerializeObjectToJSON(inputObj) {
	// BEGIN USER CODE
	var guid = inputObj.getGuid();
	var processedRefs = [ ];

	let mxObj = await retrieveObject(guid);
	let obj = await serializeMxObject(mxObj);

	return JSON.stringify(obj);

	async function serializeMxObject(mxObject) {
		console.debug("Serializing Mendix object " + mxObject.getGuid() + " (" + mxObject.getEntity() +")");
		let attributes = mxObject.getAttributes();

		let res = {};
		for (let i = 0; i < attributes.length; i++) {
			if (!mxObject.isObjectReference(attributes[i]) &&
				!mxObject.isObjectReferenceSet(attributes[i])) {
					res[attributes[i]] = mxObject.get(attributes[i]);
					
					if (res[attributes[i]] != null) {
						if (mxObject.isNumeric(attributes[i])) {
							res[attributes[i]] = Number(res[attributes[i]].toString());
						} else if (mxObject.isDate(attributes[i]) && res[attributes[i]] != "") {
							// use toISOString to conform to the export mapping at the Mendix Runtime's default format
							res[attributes[i]] = (new Date(res[attributes[i]])).toISOString();
						}
					}
			} else {
				let refGuid = mxObject.get(attributes[i]);
				if (refGuid == null || refGuid == "" || processedRefs.includes(attributes[i])) {
					continue; // skip objects which have already been processed to avoid infinite loops
				}
				processedRefs.push(attributes[i]);
				
				let refObj = await retrieveObject(refGuid);
				let serializedObj = await serializeMxObject(refObj);
				let nonFQref = attributes[i].substring(attributes[i].indexOf('.') + 1);
				res[nonFQref] = serializedObj;				
			}
		}
			
		let associations = getNotOwningAssociations(mxObject);
		for (let i = 0; i < associations.length; i++) {
			let ass = associations[i];
			let nonFQref = ass.ref.substring(ass.ref.indexOf('.') + 1);
			
			if (processedRefs.includes(ass.ref)) {
				continue;
			} else {
				processedRefs.push(ass.ref);
			}
			
			let objs = await retrieveByPath(mxObject, ass);
			let serializedObjArr = [];
			for (let j = 0; j < objs.length; j++) {
				let serializedObj = await serializeMxObject(objs[j]);
				serializedObjArr.push(serializedObj);
			}

			res[nonFQref] = serializedObjArr;
		}

		return res;
	}

	function retrieveByPath(mxObject, association) {
	 	return new Promise(function (resolve, reject) {
	 		mx.data.get({
	 			guid: mxObject.getGuid(),
	 			path: association.ref,
	 			callback: function(objs) {
	 				resolve(objs);
	 			},
	 			error: function(err) {
	 				console.error("Error while retrieving association " + association.ref + ": " + err, err);
	 				reject(err);
	 			}
	 		});
	 	});
	}

	function retrieveObject(guid) {
		return new Promise(function (resolve, reject) {
			mx.data.get({
				guid: guid,
				callback: function(obj) {
					resolve(obj);
				},
				error: function(err) {
					console.error("Error while retrieving associated object.", err);
					reject();
				}
			})
		});
	}

	// check if there're other entities having a reference to this object.
	function getNotOwningAssociations(mxObject) {
		let entities = Object.keys(mx.meta.getMap());
		let result = [];

		for (let i = 0; i < entities.length; i++) {
			let entity = mx.meta.getEntity(entities[i]);
			if (entity === mxObject.getEntity())
				continue;

			let references = entity.getReferenceAttributes();
			for (let j = 0; j < references.length; j++) {
				if (entity.isBidirectionalReference(references[j])) {
					continue;
				}
				if (entity.getSelectorEntity(references[j]) === mxObject.getEntity()) {
					result.push({
							ref: references[j],
							parent: entity.getEntity(),
							child: mxObject.getEntity()
					});
				}
			}
		}
		return result;
	}
	// END USER CODE
}
